WHITESPACE = _{ " " | "\t" | NEWLINE }

program = { SOI ~ begin ~ statement* ~ end ~ EOI }
statement   = _{ 
  var_decl 
  | write
  | read
  | assignment 
  | function
  | loop
  | procedure
  | procedure_call }

/// BEGIN and END
begin = { "BEGIN" ~ semicolon }
end = { "END" ~ semicolon }

/// WRITE
write = { "WRITE" ~ unit ~ expr+ ~ semicolon }
read = { "READ" ~ unit ~ identifier ~ semicolon }

/// VARIABLE
var_decl = { "VARIABLE" ~ type ~ variable_name ~ semicolon }
variable_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }

/// Keywords - define all reserved words
keyword = { "BEGIN" | "END" | "WRITE" | "READ" | "VARIABLE" | "PROCEDURE" | "ENDPROCEDURE" | "EXP" }

/// [ PROCEDURES / FUNCTIONS ]
  ///
  /// [ PROCEDURES ]
  /// Container
  procedure = { start_procedure ~ statement+ ~ end_procedure }
  /// Calling - ensure the name is not a keyword
  procedure_call = { procedure_name ~ expr* ~ semicolon }
  /// PROCEDURE
  start_procedure = { "PROCEDURE" ~ procedure_name ~ procedure_argument_name_and_type* ~ semicolon }
  procedure_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  procedure_argument_name_and_type = { procedure_argument_name ~ type }
  procedure_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDPROCEDURE
  end_procedure = { "ENDPROCEDURE" ~ semicolon }
  ///
  /// [ FUNCTIONS ]
  /// Container
  function = { start_function ~ statement+ ~ end_function }
  /// Calling - ensure the name is not a keyword
  function_call = ${ function_name ~ "(" ~ expr ~ ("," ~ expr)* ~ ")"  }
  /// FUNCTION
  start_function = { "FUNCTION" ~ function_name ~ function_argument_name_and_type+ ~ semicolon }
  function_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  function_argument_name_and_type = _{ function_argument_name ~ type }
  function_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDFUNCTION
  end_function = { "ENDFUNCTION" ~ semicolon }

/// [ LOOPS / WHILES ]
  ///
  /// [ LOOPS ]
  loop = { start_loop ~ statement+ ~ end_loop }
  start_loop = { "LOOP" ~ identifier ~ expr ~ expr ~ expr? ~ semicolon }
  end_loop = { "ENDLOOP" ~ semicolon }

/// [ INTRINSIC FUNCTIONS ]
  builtin_function = _{ exp | cm }
  /// EXP
  exp = { "EXP(" ~ expr ~ ")" }
  /// CM
  cm = { "CM(" ~ expr ~ ")" }
/// [ INTRINSIC TYPES ]
  type = @{ "(" ~ inner_type ~ ")"}
  inner_type = _{
    "RE" |
    "LO" |
    "VE" |
    "CM" }

/// Assignment
assignment  = { identifier ~ ":=" ~ expr ~ semicolon }

// Expression parsing using Pratt parser
expr = { term ~ (infix_op ~ term)* }
term = _{ 
    builtin_function | 
    function_call |
    number | 
    string |
    identifier |
    "(" ~ expr ~ ")" }

// Infix operators
infix_op    = _{ add | concat }
add         = { "+" }
concat      = { "&" }

identifier  = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
number      = @{ "-"? ~ ASCII_DIGIT+ }
unit        = @{ ASCII_DIGIT+ }
string      = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
semicolon   = { ";" }